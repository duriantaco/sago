import logging
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)

_GIT_TIMEOUT = 30  # seconds


class GitIntegration:
    def __init__(self, project_path: Path) -> None:
        self.project_path = Path(project_path)
        self.logger = logging.getLogger(self.__class__.__name__)

    def is_git_repo(self) -> bool:
        return (self.project_path / ".git").exists()

    def init_repo(self) -> bool:
        if self.is_git_repo():
            self.logger.info("Git repository already exists")
            return True

        try:
            subprocess.run(
                ["git", "init"],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )
            self.logger.info("Initialized Git repository")
            return True

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to init Git repo: {getattr(e, 'stderr', str(e))}")
            return False

    def create_commit(
        self, task_id: str, task_name: str, files: list[str], message: str | None = None
    ) -> bool:
        if not self.is_git_repo():
            self.logger.warning("Not a Git repository, skipping commit")
            return False

        try:
            return self._do_create_commit(task_id, task_name, files, message)
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to create commit: {getattr(e, 'stderr', str(e))}")
            return False

    def _do_create_commit(
        self, task_id: str, task_name: str, files: list[str], message: str | None
    ) -> bool:
        for file_path in files:
            subprocess.run(
                ["git", "add", file_path],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

        status_result = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=self.project_path,
            capture_output=True,
            text=True,
            check=True,
            timeout=_GIT_TIMEOUT,
        )

        if not status_result.stdout.strip():
            self.logger.info("No changes to commit")
            return True

        if not message:
            message = self._generate_commit_message(task_id, task_name, files)

        subprocess.run(
            ["git", "commit", "-m", message],
            cwd=self.project_path,
            capture_output=True,
            text=True,
            check=True,
            timeout=_GIT_TIMEOUT,
        )

        self.logger.info(f"Created commit for task {task_id}")
        return True

    def _generate_commit_message(self, task_id: str, task_name: str, files: list[str]) -> str:
        lines = [
            f"âœ… {task_id}: {task_name}",
            "",
            "Files modified:",
        ]

        for file_path in files:
            lines.append(f"  - {file_path}")

        lines.extend(["", "Generated by sago ðŸš€"])

        return "\n".join(lines)

    def create_branch(self, branch_name: str) -> bool:
        if not self.is_git_repo():
            return False

        try:
            subprocess.run(
                ["git", "checkout", "-b", branch_name],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

            self.logger.info(f"Created branch: {branch_name}")
            return True

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to create branch: {getattr(e, 'stderr', str(e))}")
            return False

    def get_current_branch(self) -> str | None:
        try:
            result = subprocess.run(
                ["git", "branch", "--show-current"],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )
            return result.stdout.strip()

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            return None

    def push_branch(self, branch_name: str | None = None) -> bool:
        if not branch_name:
            branch_name = self.get_current_branch()

        if not branch_name:
            self.logger.error("No branch to push")
            return False

        try:
            subprocess.run(
                ["git", "push", "-u", "origin", branch_name],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

            self.logger.info(f"Pushed branch: {branch_name}")
            return True

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to push: {getattr(e, 'stderr', str(e))}")
            return False

    def create_checkpoint(self, name: str) -> str | None:
        try:
            tag_name = f"sago-checkpoint-{name}"
            subprocess.run(
                ["git", "tag", tag_name],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

            self.logger.info(f"Created checkpoint: {tag_name}")
            return tag_name

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to create checkpoint: {getattr(e, 'stderr', str(e))}")
            return None

    def rollback_to_checkpoint(self, checkpoint: str) -> bool:
        try:
            subprocess.run(
                ["git", "reset", "--hard", checkpoint],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

            self.logger.info(f"Rolled back to: {checkpoint}")
            return True

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to rollback: {getattr(e, 'stderr', str(e))}")
            return False

    def get_file_diff(self, file_path: str) -> str | None:
        try:
            result = subprocess.run(
                ["git", "diff", file_path],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )
            return result.stdout

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            return None

    def undo_last_commit(self, keep_changes: bool = True) -> bool:
        try:
            mode = "--soft" if keep_changes else "--hard"
            subprocess.run(
                ["git", "reset", mode, "HEAD~1"],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True,
                timeout=_GIT_TIMEOUT,
            )

            self.logger.info("Undid last commit")
            return True

        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            self.logger.error(f"Failed to undo commit: {getattr(e, 'stderr', str(e))}")
            return False
